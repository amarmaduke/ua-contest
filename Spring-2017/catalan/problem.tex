\begin{problem}{G: The Parenren Language}

Searle has come up with a new \textit{interesting} programming language.
It consists of only parenthesis characters, $($ and $)$.
The left most parenthesis, $($, will put the number $1$ on a virtual stack.
Having two left parenthesis characters together, like $(($, will put the number $1$ on a virtual stack and perform a \texttt{nand} operation.
Having three left parenthesis characters together, like $((($, will put the number $1$ on the virtual stack and perform a \texttt{nor} operation.
The program evaluator is greedy, so the \texttt{nor} operation consisting of three left parenthesis will be performed first always over the other two if possible.

A \texttt{nand} operation will pop off two numbers from the stack, ``and'' them, and then ``not'' the result.
So for example, \texttt{1 nand 1} will give 0, and \texttt{0 nand 1} will give 1.
A \texttt{nor} operation will pop off two numbers from the stack, ``or'' them, and then ``not'' the result.

After each \texttt{nand} or \texttt{nor} operation the result is put on the virtual stack.

A right most parenthesis will pop a number from the top of the virtual stack and print it to the screen.
One caveat is that every left parenthesis must be paired with a right parenthesis to make parsing the language simple.
If there is nothing on the virtual stack to be printed when a right parenthesis is evaluated then it does nothing.
Here are some example programs:

$((()()))$

$()()()$

$(()((()))())$

Searle is confident that this new \textit{interesting} programming language is Turing complete but he is curious about how expressive it is.
Given a number $n$, the number of paired parenthesis, Searle wants you to determine how many possible programs there are.
\end{problem}

\begin{formalin}
The input consists of one integer $n$ ($1 \leq n \leq 2000$).
\end{formalin}

\begin{formalout}
Output one integer, the number of possible programs, mod $10^7 + 14$.
\end{formalout}

\begin{datain}
4
\end{datain}
\begin{dataout}
14
\end{dataout}

\begin{datain}
1
\end{datain}
\begin{dataout}
1
\end{dataout}
